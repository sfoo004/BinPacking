Assignment #4: Bin Packing
Solve the "bin packing" problem: Given a set of weights (each between 1 and 999_999_999), the bin packing problem is to find a way to assign the weights to a minimal number of bins of capacity 1_000_000_000. This problem is difficult to solve in general, so a number of heuristics have been studied. In this assignment you will use four separate heuristics and combine those to solve both the online and offline versions, for a total of eight algorithms. In the online version, we consider the weights in the order they are presented; in the offline version, the items are sorted in non-increasing order by weight. There are four common heuristics:

-Next fit: If the item fits in the last bin that was created, place it there; otherwise create a new bin. This can be implemented in linear time.

-Worst fit: Place the item in the most empty bin in which it can fit. This can also be implemented in O(N log N) time with care by using a PriorityQueue.

-Best fit: Place the item in the most full bin in which it can fit. This can be implemented in O(N log N) time with care by maintaining a NavigableSet<Bin> with all the bins. When an additional item is added to a bin, it must be removed from the NavigableSet and then reinserted. Note that because there may be multiple bins that are equally full, a NavigableSet does not quite work because it does not support duplicates. A simple workaround is to avoid duplicates by defining the comparison function in such a way that if two bins have the same weight, the tie is broken by looking at the bin number (thus making the collection duplicate-free). You can test against the following items: 700000000, 600000000, 400000000, 300000000, 700000000, 600000000, 400000000, 300000000, 700000000, 600000000, 400000000, 300000000, which can be packed in 6 bins.

-First fit: Place the item in the first bin in which it can fit; otherwise create a new bin. This can be implemented in O(N log N) time with care by maintaining a tournament tree, as described in class. If you cannot get the tournament tree to work, I will accept, with a 12 point deduction, the straightforward O(N^2) solution, but you will likely not be able to run it on the largest test case. Indicate in your output whether you are using the tournament tree or a simple sequential scan.

Write a program that implements these heuristics in an efficient manner to find out how many bins are required for input files that I will provide. These files will range from 10 items to 1,000,000 items. Your program should output the "ideal number of bins" (the sum of all the weights, divided by 1_000_000_000, rounded up), and for each algorithm, the number of bins used, and the contents of the first 10 bins. As always, include in the output a measurement of the time taken.
